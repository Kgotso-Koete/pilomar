#!/usr/bin/python

# This software is published under the GNU General Public License v3.0.
# Also respect any pre-existing terms of any components that this incorporates.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# THIS SOFTWARE CAN CONTROL ELECTRICAL AND MECHANICAL DEVICES. 
# THERE IS THEREFORE A RISK OF INJURY FROM INCORRECT ASSEMBLY, OPERATION OR FAILURE OF COMPONENTS.
# IT IS YOUR RESPONSIBILITY TO ENSURE THE SAFETY OF THE DEVICES YOU CHOOSE TO CONTROL WITH THIS SOFTWARE.

from typing import Tuple # For type hinting.
import math
import numpy as np 

def CompassPoint(value,points=['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW']):
    """ Convert a degree value into a compass point.
        Default is 16 point compass.
        8 and 4 point compass can be generated by changing the points parameter.
        points=['N','E','S','W']
        or
        points=['N','NE','E','SE','S','SW','W','NW']             . """
    locn = int(round((value / 360) * len(points),0)) % len(points)
    return points[locn]

# ------------------------------------------------------------------------------------------------------

def AngleToHMS(value):
    """ Convert a decimal angle into Hours, Minutes, Seconds. """
    value = 24 * value / 360 # Convert from DEGREES to HOURS.
    h = value // 1 # Integer division. How many whole hours. 
    value = float(value) - h # Fractions of an hour left.
    value = value * 60 # Convert to minutes.
    m = value // 1 # Integer division. How many whole minutes. 
    s = float(value) - m # Fractions of a minute left.
    s = s * 60 # Convert to seconds.
    h = int(h) # return integer rather than float values.
    m = int(m)
    return h, m, s

# ------------------------------------------------------------------------------------------------------

def AngleToDMS(value):
    """ Convert a decimal angle into Degrees, Minutes, Seconds. """
    if value < 0: sign = -1
    else: sign = 1
    value = abs(value) # Strip out sign.
    d = value // 1 # Integer division. How many whole degrees?
    value = float(value) - d # Fractions of an hour left.
    value = value * 60 # Convert to minutes.
    m = value // 1 # Integer division. How many whole minutes. 
    s = float(value) - m # Fractions of a minute left.
    s = s * 60 # Convert to seconds.
    d = int(d * sign) # return integer rather than float values.
    m = int(m * sign)
    s = s * sign
    return d, m, s

# ------------------------------------------------------------------------------------------------------

def HMSToAngle(h,m=None,s=None,invert=True):
    """ Convert hours, minutes, seconds to angle.
        Input values can be decimals, they will be converted correctly. 
        invert = True: minutes and seconds values are made negative if hour value is negative. """
    if invert and h < 0:
        if m > 0: m = -1 * m
        if s > 0: s = -1 * s
    angle = h * 360 / 24 # Convert HOURS to angle.
    if m != None: # Minutes were specified, add those.
        angle += (m / 60) * 360 / 24
    if s != None: # Seconds were specified, add those.
        angle += (s / (60 * 60)) * 360 / 24
    return angle

# ------------------------------------------------------------------------------------------------------

def DMSToAngle(degrees=0.0,minutes=0.0,seconds=0.0):
    """ Convert degrees, minutes and seconds into degrees. """
    # Convert all values relative to 360 degrees.
    minutes = (1 / 60) * float(minutes)
    seconds = (1 / (60 * 60)) * float(seconds)
    value = degrees + minutes + seconds
    return value

# ------------------------------------------------------------------------------------------------------

def DisplayHMS(h,m,s,length=12,rounding=1):
    """ Display HMS values in human readable format.
        h = hours.
        m = minutes.
        s = seconds (can be decimal). 
        length = length of returned string. 
        rounding = number of decimals precision in the seconds value. """
    hs = str(int(h))
    if len(hs) < 2: hs = hs.rjust(2)
    ms = str(int(m))
    if len(ms) < 2: ms = ms.rjust(2)
    ss = str(round(s,rounding))
    if len(ss.split('.')[0]) < 2: ss = ' ' + ss
    DH = hs + "h " + ms + "m " + ss + "s"
    DH = DH.rjust(length," ")[(-1 * length):]
    return DH

# ------------------------------------------------------------------------------------------------------

def DisplayDegree(value,length=10,zerofill=True,symbol=None):
    """ Display a degree decimal with 3dp and right justified to specified length. 
        length = size of field to return (value right justified)
               = None: Don't fill or justify. 
        zerofill = True: zerofill leading and trailing digits.
        zerofill = False: zerofill only trailing digits. 
        symbol = symbol or text to use as 'degree' unit. """
    if value is None: # No value, just return blank.
        disp = str(value).rjust(length,' ')
    else: # Value, format it.
        if zerofill: # Leading zeros should be filled.
            disp = str(format(abs(value), '07.3f')) # Fill without sign.
            if value < 0: disp = "-" + disp # Add sign back.
        else: # Leading zeros not required.
            disp = str(format(value, '.3f'))
        if symbol != None: disp += symbol
        if length != None: # Field length specified, right justify to fit.
            disp = ((" " * length) + disp)[(-1 * length):]
    return disp

# ------------------------------------------------------------------------------------------------------

def Deg3dp(value,symbol=None):
    """ Turn a degree decimal into a simple zerofilled, 3dp string.

        45.0     -->> 045.000
        -45      -->> -045.000
        
        45,'deg' -->> 045.000deg

    """
    if value != None:
        result = DisplayDegree(value,length=None,symbol=symbol)
        if value >= 0:
            result = " " + result # blank space where '+' sign would be.
    else: result = "None" # No value set.
    return result

# -----------------------------------------------------------------------------------------------------

def AltAzToXYZ(alt: float, az: float, distance:float =1.0) -> Tuple[float, float, float]:
    """ Convert alt,az angles to XYZ coordinates. Based upon originlab definition on web. 
        X and Y web definitions are swapped to match alignment in Pilomar space. 
        Z = ZENITH - NADIR axis. ZENITH is +ve. NADIR is -ve.
        X = EAST - WEST axis.    EAST is +ve.   WEST is -ve.
        Y = NORTH - SOUTH axis.  NORTH is +ve.  SOUTH is -ve.
        """
    try:
        y = distance * math.cos(math.radians(alt)) * math.cos(math.radians(az))
        x = distance * math.cos(math.radians(alt)) * math.sin(math.radians(az))
        z = distance * math.sin(math.radians(alt))
    except Exception as e:
        print("pilomartrig: AltAzToXYZ(",alt,az,distance,") Failed:",e)
        x = y = z = None
    return x,y,z 

# ------------------------------------------------------------------------------------------------------

def RotateXYZonZaxis(x,y,z,angle):
    """ Rotate x,y cooordinates by an angle around z axis. 
        Z = ZENITH - NADIR axis. ZENITH is +ve. NADIR is -ve.
        X = EAST - WEST axis.    EAST is +ve.   WEST is -ve.
        Y = NORTH - SOUTH axis.  NORTH is +ve.  SOUTH is -ve.
        """
    try:
        hyp = math.sqrt(x * x + y * y)
        OrigAngle = math.degrees(math.atan2(y,x))
        NewAngle = OrigAngle - angle
        NewX = math.cos(math.radians(NewAngle)) * hyp
        NewY = math.sin(math.radians(NewAngle)) * hyp
    except Exception as e:
        print("pilomartrig: RotateXYZonZaxis(",x,y,z,angle,") Failed:",e)
        NewX = NewY = None
    return NewX,NewY,z

# ------------------------------------------------------------------------------------------------------

def RotateXYZonXaxis(x,y,z,angle):
    """ Rotate y,z cooordinates by an angle around x axis.
        Z = ZENITH - NADIR axis. ZENITH is +ve. NADIR is -ve.
        X = EAST - WEST axis.    EAST is +ve.   WEST is -ve.
        Y = NORTH - SOUTH axis.  NORTH is +ve.  SOUTH is -ve.
        """
    try:
        hyp = math.sqrt(y * y + z * z)
        OrigAngle = math.degrees(math.atan2(z,y))
        NewAngle = OrigAngle + angle
        NewY = math.cos(math.radians(NewAngle)) * hyp
        NewZ = math.sin(math.radians(NewAngle)) * hyp
    except Exception as e:
        print("pilomartrig: RotateXYZonXaxis(",x,y,z,angle,") Failed:",e)
        NewY = NewZ = None
    return x,NewY,NewZ

# ------------------------------------------------------------------------------------------------------

def XYZToAltAz(x:float, y:float, z:float) -> Tuple[float, float]:
    """ Convert 3D coordinates into altitude and azimuth.
        Z = ZENITH - NADIR axis. ZENITH is +ve. NADIR is -ve.
        X = EAST - WEST axis.    EAST is +ve.   WEST is -ve.
        Y = NORTH - SOUTH axis.  NORTH is +ve.  SOUTH is -ve.
    """
    try:
        range = math.sqrt(x * x + y * y)
        alt = math.degrees(math.atan2(z,range))
        az = math.degrees(math.atan2(x,y)) % 360
    except Exception as e:
        print("pilomartrig: XYZToAltAz(",x,y,z,") Failed:",e)
        alt = az = None
    return alt, az

# ------------------------------------------------------------------------------------------------------

def RelativeAltAz(StarAlt,StarAz,LookAtAlt,LookAtAz):
    """ Calculate the angles of a star relative to some look-at position. 
        There will be some wonderfully clever maths to do this cleanly, quickly and precisely.
        But this was developed with trial and error, and it works well enough for me and is modifiable as required. """
    PlotX, PlotY, PlotZ = AltAzToXYZ(StarAlt,StarAz) # Place star on celestial sphere (unit 1)
    
    # Swing round to LOOK-AT Azimuth.
    NewY = PlotY * math.cos(math.radians(-1 * LookAtAz)) - PlotX * math.sin(math.radians(-1 * LookAtAz)) # 0degrees is due north on Y axis. 90degrees is due east on X axis.
    NewX = PlotX * math.cos(math.radians(-1 * LookAtAz)) + PlotY * math.sin(math.radians(-1 * LookAtAz))
    PlotX = NewX
    PlotY = NewY
    
    # Drop down to LOOK-AT Altitude.
    NewY = PlotY * math.cos(math.radians(-1 * LookAtAlt)) - PlotZ * math.sin(math.radians(-1 * LookAtAlt)) # 0degrees is due north on Y axis. 90degrees is straight up on Z axis.
    NewZ = PlotZ * math.cos(math.radians(-1 * LookAtAlt)) + PlotY * math.sin(math.radians(-1 * LookAtAlt))
    PlotY = NewY
    PlotZ = NewZ
    
    PlotStarAlt, PlotStarAz = XYZToAltAz(PlotX,PlotY,PlotZ) # Convert from an x,y,z location back into Alt/Az combination.
    # Clip result to +/- 180Degrees because we're relative to the 'centre' of the map we're drawing.
    PlotStarAz = PlotStarAz % 360
    if PlotStarAz > 180: PlotStarAz -= 360
    PlotStarAlt = PlotStarAlt % 360
    if PlotStarAlt > 180: PlotStarAlt -= 360
    return PlotStarAlt, PlotStarAz
    
# ------------------------------------------------------------------------------------------------------

def CalculateVector(FromX, FromY, ToX, ToY):
    """ Return ANGLE and PIXEL DISTANCE from 1 point to another. """
    XDist = ToX - FromX
    YDist = ToY - FromY
    PixDist = round(math.sqrt((XDist ** 2) + (YDist ** 2)),0)
    PixAngle = round(math.degrees(math.atan2(XDist,YDist)),0)
    return PixDist, PixAngle

# ------------------------------------------------------------------------------------------------------

def CompoundAngle(alt,az):
    """ Given alt,az, return compound angle from 0,0 to the point. """
    rComp = math.degrees(math.acos( math.cos(math.radians(az)) * math.cos(math.radians(alt)) )) # Compound angle from Alt & Az combined.
    return rComp

# ------------------------------------------------------------------------------------------------------

def CompoundRelativeAngle(to_alt,to_az,from_alt,from_az):
    """ Calculate angular displacement of (to_alt, to_az) from (from_alt, from_az) 
        Used to calculate if something is within field of view. """
    rX, rY, rZ = AltAzToXYZ(to_alt,to_az) # Convert TO position to 3d space.
    rX, rY, rZ = RotateXYZonZaxis(rX, rY, rZ, -1 * from_az) # Subtract FROM position.
    rX, rY, rZ = RotateXYZonXaxis(rX, rY, rZ, -1 * from_alt)
    rAlt, rAz = XYZToAltAz(rX, rY, rZ) # Convert RELATIVE position back to alt/az.
    if rAlt > 180: rAlt = rAlt - 360 # Keep within +/1 180 degrees
    if rAz > 180: rAz = rAz - 360
    rAlt = abs(rAlt) # All values +ve distances.
    rAz = abs(rAz)
    rComp = CompoundAngle(alt=rAlt,az=rAz) # Compound angle from Alt & Az combined.
    return rComp

# ------------------------------------------------------------------------------------------------------

def VectorToPixel(FromX, FromY, PixDist, PixAngle):
    """ Given ANGLE and PIXEL DISTANCE from 1 point, return the resulting point. """
    rad = math.radians(PixAngle)
    ToX = PixDist * math.sin(rad) + FromX
    ToY = PixDist * math.cos(rad) + FromY
    return int(ToX), int(ToY)

# ------------------------------------------------------------------------------------------------------

def PixelToCentreVector(ToX, ToY, width, height):
    """ Given any pixel location in an image, return its vector relative to the centre of the image. """
    PixDist, PixAngle = CalculateVector(int(width/2),int(height/2), ToX, ToY)
    return PixDist, PixAngle

# ------------------------------------------------------------------------------------------------------

def AzAltText(az,alt,symbol=None) -> str:
    """ Return standardised string of Altitude and Azimuth coordinates. """
    if symbol is None: symbol = "deg"
    return "az: " + Deg3dp(az) + symbol + " alt: " + Deg3dp(alt) + symbol

# ------------------------------------------------------------------------------------------------------

def RaDecText(radeg,decdeg,symbol=None):
    th, tm, ts = AngleToHMS(radeg) # Convert deg to hms.
    temp = DisplayHMS(th,tm,ts).strip() # Convert to string.
    return "RA: " + temp + " Dec: " + Deg3dp(decdeg) + symbol # Return entire string.

# ------------------------------------------------------------------------------------------------------

